{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\r\n * Created with @iobroker/create-adapter v2.2.0\r\n */\r\n\r\n// The adapter-core module gives you access to the core ioBroker functions\r\n// you need to create an adapter\r\nimport * as utils from '@iobroker/adapter-core';\r\nimport * as mqtt from 'mqtt';\r\n\r\n// interfaces\r\ninterface Presence {\r\n    room  : string,\r\n    names : Array<string>;\r\n    lastSeen : number;\r\n}\r\n\r\nclass Espresence extends utils.Adapter {\r\n    // class members\r\n    _presence : Presence;\r\n    _timeouts : object;\r\n\r\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\r\n        super({\r\n            ...options,\r\n            name: 'espresence',\r\n        });\r\n        this.on('ready', this.onReady.bind(this));\r\n        this.on('stateChange', this.onStateChange.bind(this));\r\n        // this.on('objectChange', this.onObjectChange.bind(this));\r\n        // this.on('message', this.onMessage.bind(this));\r\n        this.on('unload', this.onUnload.bind(this));\r\n        // init\r\n        this._presence = {};\r\n        this._timeouts = {};\r\n    }\r\n\r\n    initRoom(room : string) : void {\r\n        this._presence[room] = [];\r\n    }\r\n\r\n    getPeopleInRoom(room : string) : number {\r\n        return this._presence[room].length;\r\n    }\r\n\r\n    getPresenceInRoom(room :  string) : boolean {\r\n        return this._presence[room].length > 0;\r\n    }\r\n\r\n    getNamesInRoom(room : string) : string {\r\n        return this._presence[room].join(',');\r\n    }\r\n\r\n    setNamesInRoom(room : string, newJoiner : string) : void {\r\n        if (!this._presence[room].includes(newJoiner)){\r\n            this._presence[room].push(newJoiner);\r\n            Object.keys(this._presence).forEach( (key)=>{\r\n                this.log.debug(`Testing whether ${newJoiner} is in room ${key}`);\r\n                if (key != room){\r\n                    if (this.isPersonInRoom(newJoiner, key)){\r\n                        this.removeNameFromRoom(key , newJoiner);\r\n                    }\r\n                }\r\n            })\r\n        }\r\n        this._presence[room].lastSeen = new Date();\r\n    }\r\n\r\n    isPersonInRoom(person: string, room : string) : boolean {\r\n        return this._presence[room].includes(person);\r\n    }\r\n\r\n    removeNameFromRoom(room : string, name : string) : void {\r\n        if (typeof this._presence[room] === 'undefined') return;\r\n        const index = this._presence[room].indexOf(name);\r\n        if (index > -1) { // only splice array when item is found\r\n            this._presence[room].splice(index, 1); // 2nd parameter means remove one item only\r\n        }\r\n    }\r\n    /**\r\n     * Is called when databases are connected and adapter received configuration.\r\n     */\r\n    private async onReady(): Promise<void> {\r\n        this.setup(this);\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const adapter = this;\r\n        const adapterLog = this.log;\r\n        const adapterConfig = this.config;\r\n        const options = {\r\n            // Clean session\r\n            clean: true,\r\n            connectTimeout: 4000,\r\n            protocolVersion: 3,\r\n            protocolId: 'MQIsdp',\r\n            // Auth\r\n            clientId: 'ESPresence.' + this.instance,\r\n            username: adapterConfig.user,\r\n            password: adapterConfig.password,\r\n        }\r\n        // Initialize your adapter here\r\n        adapterLog.info(`Connecting to MQTT broker [${adapterConfig.mqttBroker}:${adapterConfig.mqttPort}]`);\r\n        const client = mqtt.connect(`mqtt://${adapterConfig.mqttBroker}:${adapterConfig.mqttPort}`, options);\r\n\r\n        client.on('connect', function (connACK) {\r\n            if (connACK.returnCode===0){\r\n                adapterLog.info(`MQTT connection to broker [${adapterConfig.mqttBroker}:${adapterConfig.mqttPort}] established.`);\r\n                // Subscribes to the status topic to receive updates\r\n                client.subscribe('#', function(err, granted) {\r\n                    if (err) {\r\n                        adapterLog.error(`Error during subscription: ${JSON.stringify(err)}`);\r\n                    } else {\r\n                        adapterLog.debug(`Subscribed to topic ${granted[0].topic}.`);\r\n                    }\r\n                });\r\n            } else {\r\n                adapterLog.info(`Error during connect: ${JSON.stringify(connACK)}`);\r\n            }\r\n        });\r\n\r\n        client.on('message', function (topic, payload) {\r\n            adapterLog.debug(`MQTT topic [${topic}] received message: ${payload.toString()}`);\r\n            const topicArray = topic.split('/');\r\n            const baseTopic   = topicArray.shift();\r\n            const level2Topic = topicArray.shift();\r\n            const newTopic = topicArray.join('.');\r\n            let   room = null;\r\n            if (level2Topic === 'rooms') {\r\n                const room = topicArray.shift();\r\n                if (adapter._presence[room]) {\r\n                    return;\r\n                } else {\r\n                    adapter.initRoom(room);\r\n                    adapter.setPresenceInRoom(adapter, room);\r\n                }\r\n            }\r\n            if (level2Topic === 'devices'){\r\n                room = topicArray.pop();\r\n                if (!adapter._presence[room]) return;\r\n                const device    : string = topicArray.pop() || 'NoDevice';\r\n                const newJoiner : string|undefined = adapter.getUserByBTLEID(adapterConfig, device);\r\n                if (newJoiner && room) {\r\n                    // adapterLog.debug(`Topic-Parts: Base-Topic: ${baseTopic}, New-Topic: ${newTopic}, Room: ${room}, Newjoiner: ${newJoiner}`);\r\n                    clearInterval(adapter._timeouts[`${room}_${newJoiner}`]);\r\n                    adapter.setNamesInRoom(room, newJoiner);\r\n                    adapter.setPresenceInRoom(adapter, room);\r\n                    const timeout : number = 7000;\r\n                    adapter._timeouts[`${room}_${newJoiner}`] = setInterval((adapter: Espresence, rooms: string, name: string) => {\r\n                        adapterLog.debug(`Timeout! Room: ${room}, User: ${name}, Now: ${Date.now()}, lastSeen: ${adapter._presence[room].lastSeen}, Diff: ${Date.now() - adapter._presence[room].lastSeen}`);\r\n                        if ( (Date.now() - adapter._presence[room].lastSeen) > timeout+10 ){\r\n                            adapter.removeNameFromRoom(room, name);\r\n                            adapter.setPresenceInRoom(adapter, room);\r\n                        }\r\n                    }, 2000, adapter, room, newJoiner);\r\n                } else{\r\n                    adapterLog.warn(`Person in room (${room}) is unknown. Please add device with BTLE_ID[${device}] to the configuration.`);\r\n                }\r\n            } else {\r\n                // adapterLog.debug(`Topic-Parts: Base-Topic: ${baseTopic}, New-Topic: ${newTopic}`);\r\n                // if (baseTopic === 'homeassistant' || baseTopic === 'info') return;\r\n                return;\r\n            }\r\n            adapterLog.debug(`New msg topic: ${newTopic}`);\r\n            adapter.processMsg(adapter, newTopic, payload.toString() );\r\n        });\r\n\r\n        client.on('error', function (error) {\r\n            adapterLog.warn('MQTT server returned error: ' + error);\r\n        });\r\n\r\n        client.on('reconnect', function () {\r\n            adapterLog.info('Reconnecting to mqtt server.');\r\n        });\r\n\r\n        client.on('close', function () {\r\n            adapterLog.info('Disconnected from mqtt server.');\r\n        });\r\n\r\n        client.on('offline', function () {\r\n            adapterLog.info('MQTT offline.');\r\n        });\r\n        /*\r\n        For every state in the system there has to be also an object of type state\r\n        Here a simple template for a boolean variable named 'testVariable'\r\n        Because every adapter instance uses its own unique namespace variable names can't collide with other adapters variables\r\n        */\r\n\r\n        // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\r\n        // You can also add a subscription for multiple states. The following line watches all states starting with 'lights.'\r\n        // this.subscribeStates('lights.*');\r\n        // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\r\n        // this.subscribeStates('*');\r\n\r\n    }\r\n\r\n    setup(adapter : Espresence) : void {\r\n        const objData : ioBroker.SettableObject = {\r\n            type: 'folder',\r\n            common: {'name': 'Presence folder',\r\n                'read': true,\r\n                'write': false,\r\n                type: 'object'\r\n            },\r\n            native: {}\r\n        };\r\n        adapter.createOrExtendObject(adapter, `presence`, objData, null);\r\n    }\r\n\r\n    async setPresenceInRoom(adapter : Espresence, room : string) : Promise<void> {\r\n        await adapter.createOrExtendObject(adapter, `presence.${room}`, {\r\n            type: 'state',\r\n            common: {'name': '',\r\n                'read': true,\r\n                'write': false,\r\n                'role': 'indicator',\r\n                'type': 'boolean'\r\n            },\r\n            native: {}\r\n        }, adapter.getPresenceInRoom(room));\r\n        await adapter.createOrExtendObject(adapter, `presence.${room}.people_in_room`, {\r\n            type: 'state',\r\n            common: {'name': '',\r\n                'read': true,\r\n                'write': false,\r\n                'role': 'value',\r\n                'type': 'number'\r\n            },\r\n            native: {}\r\n        }, adapter.getPeopleInRoom(room));\r\n        await adapter.createOrExtendObject(adapter, `presence.${room}.names`, {\r\n            type: 'state',\r\n            common: {'name': '',\r\n                'read': true,\r\n                'write': false,\r\n                'role': 'value',\r\n                'type': 'string'\r\n            },\r\n            native: {}\r\n        }, adapter.getNamesInRoom(room));\r\n    }\r\n\r\n    getUserByBTLEID(adapterConfig : Espresence.AdapterConfig, BTLE_ID : string) : string|undefined{\r\n        for (let n=0; n < adapterConfig.devices.length; n++){\r\n            if (adapterConfig.devices[n].BTLE_ID === BTLE_ID)\r\n                return adapterConfig.devices[n].name;\r\n        }\r\n    }\r\n\r\n    isNumber(str : string): boolean {\r\n        return !Number.isNaN( Number.parseFloat(str) );\r\n    }\r\n\r\n    processObject(adapter : Espresence, topic : string, objData : ioBroker.SettableObject, payload : object) : void{\r\n        if (typeof payload === 'undefined' || payload === null) return;\r\n        adapter.createOrExtendObject(adapter, topic, objData, null);\r\n        Object.keys(payload).forEach(function(key) {\r\n            objData.type = 'state';\r\n            objData.common.role = `value`;\r\n            objData.common.type = `${typeof payload[key]}`;\r\n            adapter.createOrExtendObject(adapter, topic + `.${key}`, objData, payload[key]);\r\n        })\r\n    }\r\n\r\n    processMsg(adapter : Espresence, topic : string, payload : string) : void{\r\n        if (typeof payload === 'undefined' || payload === null) return;\r\n        let value : any = payload;\r\n        const objData : ioBroker.SettableObject = {\r\n            type: 'state',\r\n            common: {'name': topic.split('.').pop() || '',\r\n                'read': true,\r\n                'write': false,\r\n                'role': 'value',\r\n                'type': 'string'\r\n            },\r\n            native: {}\r\n        };\r\n\r\n        if (topic.split('.').shift() === 'devices'){\r\n            objData.type = 'folder';\r\n            objData.common.role='';\r\n            adapter.processObject(adapter, topic, objData, JSON.parse(payload) );\r\n        }\r\n\r\n        if (topic.split('.').pop() === 'telemetry'){\r\n            objData.type = 'folder';\r\n            objData.common.role='';\r\n            adapter.processObject(adapter, topic, objData, JSON.parse(payload) );\r\n        }\r\n\r\n        if ( adapter.isNumber(value) ){\r\n            objData.common.type='number';\r\n            value = Number.parseFloat(value);\r\n        }\r\n        if (value==='NaN') value=null;\r\n\r\n        adapter.createOrExtendObject(adapter, topic, objData, value);\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Function Create or extend object\r\n     *\r\n     * Updates an existing object (id) or creates it if not existing.\r\n     * In case id and name are equal, it will only set it's new state\r\n     *\r\n     * @param {object} adapter link to the adapters instance\r\n     * @param {string} id path/id of datapoint to create\r\n     * @param {object} objData details to the datapoint to be created (Device, channel, state, ...)\r\n     * @param {any} value value of the datapoint\r\n     */\r\n    createOrExtendObject(adapter : Espresence, id : string, objData : ioBroker.SettableObject, value : any) : void{\r\n        adapter.getObject(id, function (err, oldObj) {\r\n            if (!err && oldObj) {\r\n                if ( objData.name === oldObj.common.name ){\r\n                    adapter.setState(id, value, true);\r\n                } else{\r\n                    adapter.extendObject(id, objData, () => {adapter.setState(id, value, true);});\r\n                }\r\n            } else {\r\n                adapter.setObjectNotExists(id, objData, () => {adapter.setState(id, value, true);});\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\r\n     */\r\n    private onUnload(callback: () => void): void {\r\n        try {\r\n            // Here you must clear all timeouts or intervals that may still be active\r\n            // clearTimeout(timeout1);\r\n            // clearTimeout(timeout2);\r\n            // ...\r\n            // clearInterval(interval1);\r\n\r\n            callback();\r\n        } catch (e) {\r\n            callback();\r\n        }\r\n    }\r\n\r\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\r\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\r\n    // /**\r\n    //  * Is called if a subscribed object changes\r\n    //  */\r\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\r\n    //     if (obj) {\r\n    //         // The object was changed\r\n    //         this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\r\n    //     } else {\r\n    //         // The object was deleted\r\n    //         this.log.info(`object ${id} deleted`);\r\n    //     }\r\n    // }\r\n\r\n    /**\r\n     * Is called if a subscribed state changes\r\n     */\r\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\r\n        if (state) {\r\n            // The state was changed\r\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\r\n        } else {\r\n            // The state was deleted\r\n            this.log.info(`state ${id} deleted`);\r\n        }\r\n    }\r\n\r\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\r\n    // /**\r\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\r\n    //  * Using this method requires 'common.messagebox' property to be set to true in io-package.json\r\n    //  */\r\n    // private onMessage(obj: ioBroker.Message): void {\r\n    //     if (typeof obj === 'object' && obj.message) {\r\n    //         if (obj.command === 'send') {\r\n    //             // e.g. send email or pushover or whatever\r\n    //             this.log.info('send command');\r\n\r\n    //             // Send response in callback if required\r\n    //             if (obj.callback) this.sendTo(obj.from, obj.command, 'Message received', obj.callback);\r\n    //         }\r\n    //     }\r\n    // }\r\n\r\n}\r\n\r\nif (require.main !== module) {\r\n    // Export the constructor in compact mode\r\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Espresence(options);\r\n} else {\r\n    // otherwise start the instance directly\r\n    (() => new Espresence())();\r\n}"],
  "mappings": "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",
  "names": ["room", "adapter"]
}
